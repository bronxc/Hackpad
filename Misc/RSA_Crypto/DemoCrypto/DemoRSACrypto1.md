##DemoRSACrypto1

在一个bolg上看到了一篇RSA Crypto的文章，顺便自己试了试

源文件为

	{920139713,19}
	 
	704796792
	752211152
	274704164
	18414022
	368270835
	483295235
	263072905
	459788476
	483295235
	459788476
	663551792
	475206804
	459788476
	428313374
	475206804
	459788476
	425392137
	704796792
	458265677
	341524652
	483295235
	534149509
	425392137
	428313374
	425392137
	341524652
	458265677
	263072905
	483295235
	828509797
	341524652
	425392137
	475206804
	428313374
	483295235
	475206804
	459788476
	306220148


然后分析这个文件，{920139713,19} 这个讲道理的话，明显是n和e，下面的内容就是密文了

分解n值，这个n值比较小，可以跑，也可以在线跑

py

	n = 2
	while(n < 920139713):
		if(920139713%n == 0):
			print n,920139713%n
		n = n + 1



在线：<http://factordb.com/index.php>

得到了920139713 = 18443 * 49891
所以p = 18443，q = 49891

再而求出的n的欧拉数，即 no = (18443-1) * (49891 - 1) = 920071380

得到n的欧拉数后，利用公式ed % no = 1
可得到 ed + no * k = 1

所以 19d + 920071380k = 1
然后解这个一元二次方程

py

	def ext_euclid ( e , no ):
	    if (no == 0):
	        return 1, 0, e
	    else:
	        d , k , q = ext_euclid( no , e % no )
	        d , k = k, ( d - (e // no) * k )
	        return d, k, q
	
	e = 19		
	no = 920071380
	print ext_euclid(e, no);


运行结果为：(96849619, -2, 1)
所以 d = 96849619

好了，现在我们知道
n = 920139713
e = 19
d = 96849619

那现在可以解密了,(list 就是上面的密文，太多了，)


	import binascii
	
	list = []
	
	n = 920139713
	d = 96849619
	for c in list:
		m = hex(pow(c, d, n)).rstrip("L")
		#print m
		print binascii.unhexlify(m[2:]),


然后就得到了结果：
f l a g { 1 3 2 1 2 j e 2 u e 2 8 f y 7 1 w 8 u 8 7 y 3 1 r 7 8 e u 1 e 2 }

</br>
-----------------------------------------------
参考文档：
52:<http://www.52pojie.cn/thread-490769-1-1.html>